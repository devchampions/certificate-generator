
import groovy.xml.XmlUtil
import org.apache.avalon.framework.configuration.Configuration
import org.apache.avalon.framework.configuration.DefaultConfigurationBuilder
import org.apache.avalon.framework.container.ContainerUtil
import org.apache.batik.transcoder.TranscoderException
import org.apache.batik.transcoder.TranscoderInput
import org.apache.batik.transcoder.TranscoderOutput
import org.apache.fop.svg.PDFTranscoder

import static java.lang.Boolean.FALSE
import static java.nio.charset.StandardCharsets.UTF_8
import static org.apache.batik.transcoder.SVGAbstractTranscoder.KEY_PIXEL_UNIT_TO_MILLIMETER
import static org.apache.batik.transcoder.XMLAbstractTranscoder.KEY_XML_PARSER_VALIDATING
import static org.apache.fop.svg.AbstractFOPTranscoder.KEY_AUTO_FONTS
import static org.apache.fop.svg.AbstractFOPTranscoder.KEY_STROKE_TEXT

import org.apache.batik.transcoder.image.JPEGTranscoder
import org.apache.batik.transcoder.SVGAbstractTranscoder
import org.apache.batik.transcoder.XMLAbstractTranscoder
import org.apache.fop.svg.AbstractFOPTranscoder
import org.apache.batik.transcoder.TranscoderInput
import org.apache.batik.transcoder.TranscoderOutput

import groovy.util.XmlSlurper
import groovy.xml.XmlUtil

import java.awt.image.BufferedImage
import java.awt.Graphics2D
import java.awt.Color

import org.apache.batik.transcoder.TranscoderException
import org.apache.batik.transcoder.TranscoderInput
import org.apache.batik.transcoder.TranscoderOutput
import org.apache.fop.svg.PDFTranscoder

import static javax.imageio.ImageIO.*


buildscript {
  repositories { mavenCentral() }
  dependencies {
    classpath 'org.apache.xmlgraphics:batik-transcoder:1.8'
    classpath 'org.apache.xmlgraphics:batik-codec:1.7'
    classpath 'org.apache.xmlgraphics:xmlgraphics-commons:2.1'
    classpath 'org.apache.xmlgraphics:fop:2.1'
    classpath 'org.apache.pdfbox:fontbox:1.8.12'
  }
}

task generateCertificates << {
  buildDir.mkdirs()
  File svgTemplate = file("templates/${certificateTemplate}")
  int fileIndex = 1
  forEachPerson { name, certId ->
    logger.quiet "> Generating certificate for ${name}"
    File svgCertificateFile = file("${buildDir}/${certId}.svg")    
    svgCertificateFile.text = modifySVG(svgTemplate.text, name, certId)
    renderCertificateImage(svgCertificateFile, file("${buildDir}/rendered/${certId}"), certId)
    renderCertificateHTML(file("${buildDir}/rendered/${certId}"), certId)
    renderCertificatePDF(svgCertificateFile, file("${buildDir}/rendered/${certId}"), certId)
    svgCertificateFile.delete()
  }
}

generateCertificates.logging.captureStandardOutput LogLevel.INFO
generateCertificates.logging.captureStandardError LogLevel.INFO
// generateCertificates.outputs.dir file("${buildDir}/rendered")

task copyCertificateImages(type: Copy, dependsOn: generateCertificates) {
  forEachPerson { name, certId ->
    from ("${buildDir}/rendered/${certId}") { include '*.jpg' }
  }
  into "${buildDir}/images"
}

task zipCertificateImages(type: Zip, dependsOn: copyCertificateImages) {
  from "${buildDir}/images"
  archiveName 'certs.zip'
  destinationDir buildDir
}

task build(dependsOn: [ generateCertificates, copyCertificateImages, zipCertificateImages])

task clean(type: Delete) {
  delete buildDir
}


def modifySVG(String svgText, String name, String certId) {
  def svg = new XmlSlurper().parseText(svgText)
  def certNameElement = svg.depthFirst().find { it.@id == 'cert-name' }
  certNameElement.replaceBody(name)
  def certUrlElement = svg.depthFirst().find { it.@id == 'cert-url' }
  def certUrl = "http://certs.devchampions.com/${certId}"
  project.logger.quiet "${name} - ${certUrl}"
  certUrlElement.replaceBody(certUrl)
  XmlUtil.serialize(svg)
}


def renderCertificateImage(File svgFile, File baseDir, String baseName) {
  baseDir.mkdirs()
  JPEGTranscoder t = new JPEGTranscoder()
  t.addTranscodingHint(SVGAbstractTranscoder.KEY_PIXEL_UNIT_TO_MILLIMETER, new Float((float) (25.4 / 300)))
  t.addTranscodingHint(JPEGTranscoder.KEY_QUALITY, new Float(1))
  String svgURI = svgFile.toURL().toString()
  t.transcode(new TranscoderInput(svgURI), new TranscoderOutput(new FileOutputStream("${baseDir}/${baseName}.jpg")))
}


def renderCertificateHTML(File baseDir, String baseName) {
  new File(baseDir, 'index.html').text = """<html><body style="margin: 0px;"><img height="100%" src="${baseName}.jpg"/></body></html>"""
}


def renderCertificatePDF(File svgFile, File baseDir, String baseName) {
  baseDir.mkdirs()
  PDFTranscoder t = configureFonts(new PDFTranscoder())
  String svgURI = svgFile.toURL().toString()
  t.transcode(new TranscoderInput(svgURI), new TranscoderOutput(new FileOutputStream("${baseDir}/${baseName}.pdf")))
}


def configureFonts(PDFTranscoder t) {
  DefaultConfigurationBuilder cfgBuilder = new DefaultConfigurationBuilder()
  Configuration cfg = cfgBuilder.build(rendererConfiguration)
  ContainerUtil.configure(t, cfg)
  t.addTranscodingHint(KEY_PIXEL_UNIT_TO_MILLIMETER, new Float((float) (25.4 / 300)))
  t.addTranscodingHint(KEY_XML_PARSER_VALIDATING, FALSE)
  t.addTranscodingHint(KEY_STROKE_TEXT, FALSE)
  t.addTranscodingHint(KEY_AUTO_FONTS, false)
  t
}


InputStream getRendererConfiguration() {
  File configFile = new File("fonts/pdf-renderer-cfg.xml")
  if (configFile.exists()) {
    println "DEBUG: Using PDF renderer configuration: ${configFile.absolutePath}"
    return configFile.newInputStream()
  } else {
    throw new RuntimeException('PDF renderer configuration is not found!')
  }
}


def forEachPerson(Closure cl) {
  File dataFile = file(project.hasProperty('dataFile') ? project.dataFile : 'data.csv')
  if (dataFile.exists()) {
    def lines = dataFile.readLines("UTF-8").drop(1).collect { it.trim() }.findAll { it.contains(';') }
    lines.each { String line ->
      def fields = line.split(';')
      cl(fields[0], fields[1])
    }
  }
}




